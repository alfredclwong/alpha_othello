<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Bokeh Plot</title>
    <style>
      html, body {
        box-sizing: border-box;
        display: flow-root;
        height: 100%;
        margin: 0;
        padding: 0;
      }
    </style>
    <script type="text/javascript" src="https://cdn.bokeh.org/bokeh/release/bokeh-3.7.3.min.js"></script>
    <script type="text/javascript" src="https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.7.3.min.js"></script>
    <script type="text/javascript">
        Bokeh.set_log_level("info");
    </script>
  </head>
  <body>
    <div id="e9780ce4-bd95-4bc9-8a27-79e02bc0a606" data-root-id="p5535" style="display: contents;"></div>
  
    <script type="application/json" id="cc9513f8-01f2-4551-b017-5ec15dc7b7b0">
      {"9771f2e2-4763-461d-bd40-46d9c2caeb7c":{"version":"3.7.3","title":"Bokeh Application","roots":[{"type":"object","name":"Row","id":"p5535","attributes":{"children":[{"type":"object","name":"Figure","id":"p5499","attributes":{"width":150,"height":1500,"x_range":{"type":"object","name":"DataRange1d","id":"p5500"},"y_range":{"type":"object","name":"DataRange1d","id":"p5501"},"x_scale":{"type":"object","name":"LinearScale","id":"p5509"},"y_scale":{"type":"object","name":"LinearScale","id":"p5510"},"title":{"type":"object","name":"Title","id":"p5502","attributes":{"text":"Evolutionary Tree"}},"renderers":[{"type":"object","name":"GraphRenderer","id":"p5539","attributes":{"layout_provider":{"type":"object","name":"StaticLayoutProvider","id":"p5556","attributes":{"graph_layout":{"type":"map","entries":[[1,[397.99,1831.9999998055555]],[2,[391.0854209966475,1739.28119262239]],[3,[459.89457900335253,1666.7188075720544]],[4,[339.99,1602.0]],[5,[424.99,1543.9999998055555]],[6,[426.73756223493035,1445.3336661150468]],[7,[347.24243776506967,1384.6663340793978]],[8,[255.99,1314.0]],[9,[338.1379823880427,1245.7335503283805]],[12,[399.9220099718147,1167.3372569861626]],[13,[328.9100076401426,1096.9291926854569]],[14,[258.3279309246228,1034.2192375413906]],[19,[211.6520690753772,945.7807624586094]],[22,[328.8420176119573,885.7335503283805]],[26,[268.1379823880427,806.2664496716195]],[32,[194.99,738.0]],[40,[270.99,666.0]],[72,[130.99,594.0]],[82,[218.53348292043452,535.0807693050917]],[91,[199.4465170795655,436.9192306949082]],[116,[84.20143409403401,378.8569420364158]],[153,[151.775565905966,305.1430579635842]],[240,[38.13498238804268,237.7335503283805]],[248,[102.23879895139677,162.27825446743677]],[277,[36.78995624900726,101.93170069873875]],[348,[41.784262411553286,2.0564945054439914]]]}}},"node_renderer":{"type":"object","name":"GlyphRenderer","id":"p5544","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p5536","attributes":{"selected":{"type":"object","name":"Selection","id":"p5537","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p5538"},"data":{"type":"map","entries":[["index",[1,2,3,4,5,6,7,8,9,12,13,14,19,22,26,32,40,72,82,91,116,153,240,248,277,348]],["score",[0,32,67,79,69,159,78,183,182,181,227,287,284,280,286,288,290,290,288,289,292,290,293,290,296,292]],["size",[20,20,20,20,20,31.8,20,36.6,36.4,36.2,45.400000000000006,57.400000000000006,56.800000000000004,56.0,57.2,57.6,58.0,58.0,57.6,57.800000000000004,58.400000000000006,58.0,58.6,58.0,59.2,58.400000000000006]],["completion",["    valid_moves = get_legal_squares(board, player)\n    return valid_moves[np.random.randint(len(valid_moves))]","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_pieces = -1\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        if num_pieces &gt; max_pieces:\n            max_pieces = num_pieces\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_pieces = -1\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n\n        # Corner prioritization\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            return move\n\n        if num_pieces &gt; max_pieces:\n            max_pieces = num_pieces\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_flips = -1\n    max_pieces = -1\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Corner prioritization\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            return move\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            continue\n\n        if num_flips &gt; max_flips:\n            max_flips = num_flips\n            max_pieces = num_pieces\n            best_move = move\n        elif num_flips == max_flips and num_pieces &gt; max_pieces:\n            max_pieces = num_pieces\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_flips = -1\n    max_pieces = -1\n    max_stable_pieces = -1\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Corner prioritization\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            return move\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            continue\n\n        if stable_pieces &gt; max_stable_pieces:\n            max_stable_pieces = stable_pieces\n            max_flips = num_flips\n            max_pieces = num_pieces\n            best_move = move\n        elif stable_pieces == max_stable_pieces:\n            if num_flips &gt; max_flips:\n                max_flips = num_flips\n                max_pieces = num_pieces\n                best_move = move\n            elif num_flips == max_flips and num_pieces &gt; max_pieces:\n                max_pieces = num_pieces\n                best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_flips = -1\n    max_pieces = -1\n    max_future_moves = -1\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate future moves\n        player_future_moves = len(get_legal_squares(temp_board, player))\n        opponent = ~player\n        opponent_future_moves = len(get_legal_squares(temp_board, opponent))\n\n        # Corner prioritization\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            return move\n\n        # Check if opponent gets a corner on next turn\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            continue\n\n        if num_flips &gt; max_flips:\n            max_flips = num_flips\n            max_pieces = num_pieces\n            max_future_moves = player_future_moves - opponent_future_moves\n            best_move = move\n        elif num_flips == max_flips and num_pieces &gt; max_pieces:\n            max_pieces = num_pieces\n            max_future_moves = player_future_moves - opponent_future_moves\n            best_move = move\n        elif num_flips == max_flips and num_pieces == max_pieces and (player_future_moves - opponent_future_moves) &gt; max_future_moves:\n            max_future_moves = player_future_moves - opponent_future_moves\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Corner prioritization\n        corner_priority = 10\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        score = (\n            num_flips * 10 +\n            num_pieces * 5 +\n            stable_pieces * 15\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Score calculation\n        score = (\n            num_flips * 10 +\n            num_pieces * 5 +\n            stable_pieces * 15\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Score calculation\n        score = (\n            num_flips * 10 +\n            num_pieces * 5 +\n            stable_pieces * 15\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Score calculation\n        score = (\n            num_flips * 12 +  # Increased flip weight\n            num_pieces * 5 +\n            stable_pieces * 15 +\n            mobility_difference * 8  # Added mobility component\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Score calculation\n        score = (\n            num_flips * 15 +  # Increased flip weight\n            num_pieces * 5 +\n            stable_pieces * 15 +\n            mobility_difference * 10  # Added mobility component\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Score calculation\n        score = (\n            num_flips * 20 +  # Increased flip weight\n            num_pieces * 5 +\n            stable_pieces * 15 +\n            mobility_difference * 10  # Added mobility component\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Score calculation\n        score = (\n            num_flips * 20 +  # Increased flip weight\n            num_pieces * 5 +\n            stable_pieces * 15 +\n            mobility_difference * 10  # Added mobility component\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -100\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # Score calculation\n        score = (\n            num_flips * 25 +  # Increased flip weight\n            num_pieces * 4 +  # Decreased piece weight\n            stable_pieces * 20 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -150\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 8\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 6 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -150\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -150\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -150\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -150\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -150\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -200  # Increased penalty\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -200  # Increased penalty\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        score = (\n            num_flips * 22 +  # Increased flip weight\n            num_pieces * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -250\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        score = (\n            num_flips * 23 +  # Increased flip weight\n            num_pieces * 3 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -250\n\n        # Center bonus\n        center_bonus = 0\n        size = get_size(board)\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        score = (\n            num_flips * 23 +  # Increased flip weight\n            num_pieces * 3 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    size = get_size(board)\n    num_pieces = np.sum(board[:, :, player.value])\n    game_stage = num_pieces / (size * size)\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces_after = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -275  # Increased penalty\n\n        # Center bonus\n        center_bonus = 0\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        flip_weight = 25 * (1 - game_stage) + 10 * game_stage\n        score = (\n            num_flips * flip_weight +  # Adjusted flip weight based on game stage\n            num_pieces_after * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n","\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    size = get_size(board)\n    num_pieces = np.sum(board[:, :, player.value])\n    game_stage = num_pieces / (size * size)\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces_after = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -275  # Increased penalty\n\n        # Center bonus\n        center_bonus = 0\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        flip_weight = 25 * (1 - game_stage) + 10 * game_stage\n        score = (\n            num_flips * flip_weight +  # Adjusted flip weight based on game stage\n            num_pieces_after * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n"]],["fill_color",["lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","lightblue","#ffcc00","lightblue"]]]}}},"view":{"type":"object","name":"CDSView","id":"p5545","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p5546"}}},"glyph":{"type":"object","name":"Circle","id":"p5557","attributes":{"radius":{"type":"field","field":"size"},"fill_color":{"type":"field","field":"fill_color"}}}}},"edge_renderer":{"type":"object","name":"GlyphRenderer","id":"p5551","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p5548","attributes":{"selected":{"type":"object","name":"Selection","id":"p5549","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p5550"},"data":{"type":"map","entries":[["start",[1,1,1,2,2,2,3,3,3,4,4,4,4,4,5,5,6,6,6,6,7,8,8,8,8,8,9,9,9,12,13,13,13,14,14,14,14,14,14,19,19,19,22,26,26,32,32,32,40,40,40,40,40,72,72,72,72,72,82,91,116,116,116,116,116,153,153,240,240,240,248,277]],["end",[2,3,4,3,4,5,4,5,6,5,6,7,8,9,6,7,7,8,9,12,8,9,12,13,14,19,12,13,14,13,14,19,22,19,22,26,32,40,72,22,26,32,26,32,40,40,72,82,72,82,91,116,153,82,91,116,153,240,91,116,153,240,248,277,348,240,248,248,277,348,277,348]]]}}},"view":{"type":"object","name":"CDSView","id":"p5552","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p5553"}}},"glyph":{"type":"object","name":"MultiLine","id":"p5547"}}},"selection_policy":{"type":"object","name":"NodesOnly","id":"p5554"},"inspection_policy":{"type":"object","name":"NodesOnly","id":"p5555"}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p5508","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p5521"},{"type":"object","name":"WheelZoomTool","id":"p5522","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p5523","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p5524","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p5530","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p5529","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}},{"type":"object","name":"SaveTool","id":"p5531"},{"type":"object","name":"ResetTool","id":"p5532"},{"type":"object","name":"HelpTool","id":"p5533"},{"type":"object","name":"HoverTool","id":"p5559","attributes":{"renderers":[{"id":"p5544"}],"callback":{"type":"object","name":"CustomJS","id":"p5558","attributes":{"args":{"type":"map","entries":[["source",{"id":"p5536"}],["div",{"type":"object","name":"Div","id":"p5534","attributes":{"styles":{"type":"map","entries":[["overflow-x","auto"],["overflow-y","auto"],["margin-top","0px"],["background","#f9f9f9"],["padding","2px"],["font-size","10px"]]},"width":550,"height":1500,"text":"&lt;b&gt;Completion #277:&lt;/b&gt;&lt;br&gt;[Score: 296]&lt;br&gt;&lt;pre style='white-space:pre-wrap;'&gt;&lt;code class='language-python'&gt;\n    valid_moves = get_legal_squares(board, player)\n    if not valid_moves:\n        return None  # No valid moves available\n\n    best_move = None\n    max_score = -float('inf')\n\n    size = get_size(board)\n    num_pieces = np.sum(board[:, :, player.value])\n    game_stage = num_pieces / (size * size)\n\n    for move in valid_moves:\n        temp_board = board.copy()\n        flips = get_flips(temp_board, player, move)\n        for flip in flips:\n            temp_board[flip[0], flip[1], player.value] = True\n            temp_board[flip[0], flip[1], (~player).value] = False\n        temp_board[move[0], move[1], player.value] = True\n        temp_board[move[0], move[1], (~player).value] = False\n\n        num_pieces_after = np.sum(temp_board[:, :, player.value])\n        num_flips = len(flips)\n\n        # Calculate stable pieces\n        stable_pieces = 0\n        for r in range(get_size(board)):\n            for c in range(get_size(board)):\n                if temp_board[r, c, player.value]:\n                    is_stable = True\n                    # Check if the piece can be flipped by the opponent\n                    for dr, dc in [\n                        (-1, -1),\n                        (-1, 0),\n                        (-1, 1),\n                        (0, -1),\n                        (0, 1),\n                        (1, -1),\n                        (1, 0),\n                        (1, 1),\n                    ]:\n                        r_opp, c_opp = r + dr, c + dc\n                        if 0 &lt;= r_opp &lt; get_size(board) and 0 &lt;= c_opp &lt; get_size(board) and temp_board[r_opp, c_opp, (~player).value]:\n                            # Check if there are any of the player's pieces in the direction\n                            r_player, c_player = r_opp + dr, c_opp + dc\n                            while 0 &lt;= r_player &lt; get_size(board) and 0 &lt;= c_player &lt; get_size(board):\n                                if temp_board[r_player, c_player, player.value]:\n                                    break\n                                elif temp_board[r_player, c_player, (~player).value]:\n                                    r_player += dr\n                                    c_player += dc\n                                else:\n                                    is_stable = False\n                                    break\n                            if not is_stable:\n                                break\n                    if is_stable:\n                        stable_pieces += 1\n\n        # Mobility calculation\n        player_mobility = len(get_legal_squares(temp_board, player))\n        opponent_mobility = len(get_legal_squares(temp_board, ~player))\n        mobility_difference = player_mobility - opponent_mobility\n\n        # Corner prioritization\n        corner_priority = 100\n        edge_priority = 5\n        opponent_corner_penalty = -275  # Increased penalty\n\n        # Center bonus\n        center_bonus = 0\n        if (size // 2 - 1 &lt;= move[0] &lt;= size // 2) and (size // 2 - 1 &lt;= move[1] &lt;= size // 2):\n            center_bonus = 10\n\n        # X-square penalty\n        x_square_penalty = 0\n        if move == (0, 1) or move == (1, 0) or move == (0, get_size(board) - 2) or move == (1, get_size(board) - 1) or \\\n           move == (get_size(board) - 2, 0) or move == (get_size(board) - 1, 1) or move == (get_size(board) - 2, get_size(board) - 1) or move == (get_size(board) - 1, get_size(board) - 2):\n            x_square_penalty = -50\n\n        # Adjacent bonus\n        adjacent_bonus = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = move[0] + dr, move[1] + dc\n            if 0 &lt;= r &lt; get_size(board) and 0 &lt;= c &lt; get_size(board) and temp_board[r, c, player.value]:\n                adjacent_bonus += 2\n\n        # Score calculation\n        flip_weight = 25 * (1 - game_stage) + 10 * game_stage\n        score = (\n            num_flips * flip_weight +  # Adjusted flip weight based on game stage\n            num_pieces_after * 4 +  # Adjusted piece weight\n            stable_pieces * 18 +  # Increased stable pieces weight\n            mobility_difference * 12 +  # Adjusted mobility weight\n            center_bonus +\n            x_square_penalty +\n            adjacent_bonus\n        )\n\n        if (move[0] == 0 and move[1] == 0) or \\\n           (move[0] == 0 and move[1] == get_size(board) - 1) or \\\n           (move[0] == get_size(board) - 1 and move[1] == 0) or \\\n           (move[0] == get_size(board) - 1 and move[1] == get_size(board) - 1):\n            score += corner_priority\n\n        elif move[0] == 0 or move[0] == get_size(board) - 1 or move[1] == 0 or move[1] == get_size(board) - 1:\n            score += edge_priority\n\n        # Check if opponent gets a corner on next turn\n        opponent = ~player\n        opponent_legal_moves = get_legal_squares(temp_board, opponent)\n        opponent_gets_corner = False\n        for opponent_move in opponent_legal_moves:\n            if (opponent_move[0] == 0 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == 0 and opponent_move[1] == get_size(board) - 1) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == 0) or \\\n               (opponent_move[0] == get_size(board) - 1 and opponent_move[1] == get_size(board) - 1):\n                opponent_gets_corner = True\n                break\n        if opponent_gets_corner:\n            score += opponent_corner_penalty\n\n        if score &gt; max_score:\n            max_score = score\n            best_move = move\n\n    if best_move is None:\n        return valid_moves[np.random.randint(len(valid_moves))] # if something goes wrong just pick a random move\n    return best_move\n&lt;/code&gt;&lt;/pre&gt;"}}]]},"code":"\n            const {indices} = cb_data.index;\n            if (indices.length &gt; 0) {\n                const idx = indices[0];\n\n                // Change color of hovered node\n                const node_renderer = cb_obj.renderers[0];\n                const node_data = node_renderer.data_source;\n                // Reset all nodes to lightblue\n                for (let i = 0; i &lt; node_data.data['index'].length; i++) {\n                    node_data.data['fill_color'] = node_data.data['fill_color'] || [];\n                    node_data.data['fill_color'][i] = \"lightblue\";\n                }\n                // Highlight hovered node\n                node_data.data['fill_color'][idx] = \"#ffcc00\";\n                node_data.change.emit();\n\n                const id = source.data['index'][idx];\n                const score = source.data['score'][idx];\n                const completion = source.data['completion'][idx];\n                div.text = \"&lt;b&gt;Completion #\" + id + \":&lt;/b&gt;&lt;br&gt;\";\n                div.text += \"[Score: \" + score + \"]&lt;br&gt;\";\n                div.text += \"&lt;pre style='white-space:pre-wrap;'&gt;&lt;code class='language-python'&gt;\";\n                div.text += completion;\n                div.text += \"&lt;/code&gt;&lt;/pre&gt;\";\n\n            }\n        "}},"tooltips":[["Completion ID","@index"],["Score","@score"]]}}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p5516","attributes":{"visible":false,"ticker":{"type":"object","name":"BasicTicker","id":"p5517","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p5518"},"major_label_policy":{"type":"object","name":"AllLabels","id":"p5519"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p5511","attributes":{"visible":false,"ticker":{"type":"object","name":"BasicTicker","id":"p5512","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p5513"},"major_label_policy":{"type":"object","name":"AllLabels","id":"p5514"}}}],"center":[{"type":"object","name":"Grid","id":"p5515","attributes":{"axis":{"id":"p5511"},"grid_line_color":null}},{"type":"object","name":"Grid","id":"p5520","attributes":{"dimension":1,"axis":{"id":"p5516"},"grid_line_color":null}}],"background_fill_color":"#f0f0f0"}},{"id":"p5534"}]}}]}}
    </script>
    <script type="text/javascript">
      (function() {
        const fn = function() {
          Bokeh.safely(function() {
            (function(root) {
              function embed_document(root) {
              const docs_json = document.getElementById('cc9513f8-01f2-4551-b017-5ec15dc7b7b0').textContent;
              const render_items = [{"docid":"9771f2e2-4763-461d-bd40-46d9c2caeb7c","roots":{"p5535":"e9780ce4-bd95-4bc9-8a27-79e02bc0a606"},"root_ids":["p5535"]}];
              root.Bokeh.embed.embed_items(docs_json, render_items);
              }
              if (root.Bokeh !== undefined) {
                embed_document(root);
              } else {
                let attempts = 0;
                const timer = setInterval(function(root) {
                  if (root.Bokeh !== undefined) {
                    clearInterval(timer);
                    embed_document(root);
                  } else {
                    attempts++;
                    if (attempts > 100) {
                      clearInterval(timer);
                      console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                    }
                  }
                }, 10, root)
              }
            })(window);
          });
        };
        if (document.readyState != "loading") fn();
        else document.addEventListener("DOMContentLoaded", fn);
      })();
    </script>
  </body>
</html>